#!/usr/bin/env python

# Copyright 2016 Bloomberg Finance L.P.
# All Rights Reserved.
# This software is proprietary to Bloomberg Finance L.P. and is
# provided solely under the terms of the BFLP license agreement.


def combined_df(response):
    """Return a :obj:`pandas.DataFrame` that combines the results from multiple 
    :class:`SingleItemResponse` objects.

    Parameters
    ----------
    response : Response
        A :class:`Response` instance or a sequence of
        :class:`SingleItemResponse` instances.

    Returns
    -------
    pandas.DataFrame
        A DataFrame containing the columns from all of the 
        :class:`SingleItemResponse` objects, generated by performing an outer 
        join on all non-value columns.

    Notes
    -----
    If the DataFrame from response A is:

    +---------------+------------+--------------+---------+
    | ID            | DATE       | CURRENCY     | px_last |
    +===============+============+==============+=========+
    | IBM US Equity | 2016-01-01 | USD          | 150.0   |
    +---------------+------------+--------------+---------+

    And the DataFrame from response B is:

    +---------------+------------+--------------+---------+
    | ID            | DATE       | CURRENCY     | px_open |
    +===============+============+==============+=========+
    | IBM US Equity | 2016-01-01 | USD          | 149.0   |
    +---------------+------------+--------------+---------+

    Then, the combined DataFrame returned would be joined on
    all columns except px_last and px_open, which are the value columns,
    producing as a result:

    +---------------+------------+--------------+---------+---------+
    | ID            | DATE       | CURRENCY     | px_last | px_open |
    +===============+============+==============+=========+=========+
    | IBM US Equity | 2016-01-01 | USD          | 150.0   | 149.0   |
    +---------------+------------+--------------+---------+---------+

    If the set of non-value columns is not the same for all involved item
    responses, then the function behaves as if empty columns were inserted
    before joining the DataFrames.

    .. note ::
        If the response input contains only a single item, `combined_df()`
        is equivalent to `df()`.

    Example
    -------
    .. code-block:: python
        :linenos:
        :emphasize-lines: 15

        # Setup environment
        import bql
        bq = bql.Service()

        data_items = {
            'Last Price': bq.data.px_last(fill='prev'),
            'Open Price': bq.data.px_open(fill='prev')
        }

        # Instantiate and execute the request 
        request = bql.Request('AAPL US Equity', data_items)
        response = bq.execute(request)

        # Unpack the data using combined_df
        data = bql.combined_df(response)
        data

    """
    import pandas

    # 1) get all DFs, and reset index. Remember column types.
    dfs = [sir.to_dataframe() for sir in response]
    column_types = {}
    for df in dfs:
        index_name = df.index.name
        df.reset_index(inplace=True)
        for column in df.columns:
            column_types[column] = df[column].dtype

    # 2) get union of non-value columns
    non_value_column_name_sets = [set(df.columns) - set([sir.name]) for df,
                                  sir in zip(dfs, list(response))]
    non_value_column_names = non_value_column_name_sets[0]
    for name_set in non_value_column_name_sets[1:]:
        non_value_column_names = non_value_column_names | name_set

    # 3) add non-value columns to DFs where necessary, with None/NaN/NaT values
    for df in dfs:
        for column_name in non_value_column_names:
            if column_name not in df.columns:
                df.loc[:, column_name] = pandas.Series(
                    [None]*len(df),
                    index=df.index,
                    dtype=column_types[column_name])

    # 4) merge all DFs on non-value columns with how='outer'
    final_df = dfs[0]
    for df in dfs[1:]:
        final_df = pandas.merge(
            final_df, df, on=list(non_value_column_names), how='outer')

    return final_df.set_index(index_name)
